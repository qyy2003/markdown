选手注意：
试题纸共有*页，答题纸共有*页，满分100分。
请在答题纸上作答，写在试题纸上的一律无效。
不得使用任何电子设备（如计算器、手机、电子词典等）或查阅任何书籍资料。


一、选择题（每题1.5分，共计30分，每题有4个选项，前十题为单选，后十题为多选，全部选对才得分）

1、____年____月____日在国际电信标准组织3GPP RAN第78次全体会议上，5G NR首发版本正式发布，这是全球第一个可商用部署的5G标准。（） 
A、2017年8月18日   B、2018年1 月1日。
C、2017年12月25日 D、2017年12月21日

2、一个有2333个节点的有根二叉树最多有几个叶子节点。 （）
A、1167 B、1166
C、1165 D、1233

3、以下几种存储器的访问速度第二快的是（）
A、Cache B、ROM
C、RAM  D、金士顿DT100G3（32GB）

4、一张10个点的完全图，任意删去一条边，它的哈密顿回路的数量为() 
A、141120  B、322560
C、161280 D、362880

5、已知2018年10月7日是星期日，那么1296年8月17日是星期（）
A. 星期一  B.星期二
C.星期五  D.星期六

6、2018年中国计算机大会将于哪里举行。 （）
A、艾泽拉斯 铁炉堡
B、中土世界 瑞文戴尔
C、中国 杭州
D、哥斯达黎加 蓬塔雷纳斯 

7、在c++中，(-7)%(-5)等于（）
A、2                             B、-2
C、3                             D、-3

8、下列各数中最大的是（） 
A、12530（六进制）       B、4AB（十三进制）
C、2111022（三进制）  D、887 (十五进制）

9、请给以下四个事件发生的时间排序（）
1.举办第一次NOIP
2.举办第一次NOI网络同步赛
3.NOIP提高组由四题改为三题
4.举办第一次APIO
A、1234   B、1243
C、2134   D、2143

10、随机抛硬币，在连续三次得到的结果是正反正时停止。那么期望抛的次数是() 
A、7    B、8
C、9    D、10

11、T(n)为某个算法输入为n时的运算次数。如果T(i)(i<=1)为常数，且T(n)=3T(sqrt(n))+logn，那么以下比T(n)复杂度低有() 
A、O(log(n)*sqrt(log(n))  B、O(sqrt(n))
C、O(log(n))                    D、O(log^2(n))

12、以下在OSI模型中不属于TCP/IP模型中的应用层的是() 
A、会话层         B、网络层
C、数据链路层 D、表示层

13.下列哪些算法是由tarjan发明的（）
A、Splay
B、LCT 
C、Median of medians linear time selection algorithm
D、Timsort

14、有三个1级分裂怪，每个x级怪可以吃掉另x-1到x+1个x级怪分裂出x^2 - 1 到 x^2+2个x + 1级分裂怪（自己死亡），求以下哪几种怪的个数情形是可能出现的？
A、0个一级分裂怪，1个二级分裂怪，6个三级分裂怪，10个四级分裂怪 
B、2个一级分裂怪，3个三级分裂怪，3个4级分裂怪，35个5级分裂怪
C、1个一级分裂怪，2个三级分裂怪，3个4级分裂怪，46个5级分裂怪
D、3个一级分裂怪

15、按1,2,3,4,5的顺序加入，以下可以是栈的出队序列的选项是（）
A、12345      B、54312
C、13254     D、15243

16、令p,q,r,s为四个命题，判定下列命题的可满足性（可满足定义为存在一组(p,q,r,s)使命题为真）。其中可满足的有（）
A、(p ∨ ¬q) ∧ (¬p ∨ q) ∧ (¬p ∨ ¬q)
B、(p → q) ∧ (p → ¬q) ∧ (¬p → q) ∧ (¬p → ¬q)
C、(p ↔ q) ∧ (¬p ↔ q)
D、(p ∨ q ∨ ¬r)∧(p ∨ ¬q ∨ ¬s)∧(p ∨ ¬r ∨ ¬s)∧(¬p ∨ ¬q ∨ ¬s) ∧ (p ∨ q ∨ ¬s)

17、给出以下邻接矩阵，其表示的图是DAG（有向无环图）的有（）


```
A、
[[0 1 1 1]
 [0 0 0 0]
 [0 0 0 1]
 [0 0 1 0]]	
B、
[[0 1 0 0]
 [0 0 0 0]
 [1 1 0 0]
 [1 1 0 0]]
C、
[[1 0 0 0]
 [0 0 1 1]
 [1 0 0 0]
 [0 0 1 0]]	
D、
[[0 0 0 0]
 [1 0 1 0]
 [0 0 0 1]
 [1 0 0 0]]
```
18、以下哪些行为是符合规范的（）
A、NOIP初赛时携带U盘进入考场 
B、NOIP初赛中，携带钢笔，圆珠笔，中性笔，记号笔，铅笔，橡皮，削笔刀进入考场
C、NOIP复赛中，竞赛结束30分钟前，为了上厕所而出考场
D、NOIP初赛快结束的时候因为做不出来大喊泄愤

19、若A=True，B=False，C=True，D=False，则下列逻辑运算真的有（）
A、(¬AVB)V(C∧DV¬D)       B、¬(¬A∧BVC)∧¬B
C、¬(A∧B)∧(CVD)         D、AVD∧¬C∧B

20、以下简称和全称对应的是（）
A、NAT（Network Address Translation）
B、TCP（Transmission Control Protocol）
C、ARP（Address Resolution Protocol）
D、ICMP是（Internet Control Message Protocol）
二、问题求解（共2题，每题5分，共10分）
1、求由10个不同元素组成的集合中，最多能选出多少个集合，它们两两不互相包含。()
2、求从1到1000之间不能被5,6和8整除的整数个数。 （）
三、阅读程序写结果（共4题，每题8分，共计32分）
1、
#include <bits/stdc++.h>
using namespace std;
int x, y;
int f(int x, int y) {
​    int ans = y;
​    for (int i = 1; i <= y - x; ++i)
​        ans += x / i * f(x + i, y - i);
​    return ans;
}
int main() {
​    scanf("%d%d", &x, &y);
​    printf("%d", f(x, y));
}
输入: 2 5
输出:______ 
2、
#include <bits/stdc++.h>
using namespace std;
int ans;
int main() {
​    for (int i = 1; i <= 100; ++i)
​        ans += i * i * i * i;
​    printf("%d", ans);
}
输出: ______ 
3、
#include <bits/stdc++.h>
using namespace std;
const int mod = 100;
int n, k, a[100];
int main() {
​    scanf("%d%d", &n, &k);
​    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
​    for (int i = 1; i <= k; ++i)
​        for (int j = 1; j <= n; ++j)
​            (a[j] += a[j - 1]) %= mod;
​    for (int i = 1; i <= n; ++i) printf("%d ", a[i]);
}
输入:
3 70
4 3 5
输出:______ 
4、
#include<bits/stdc++.h>
using namespace std;
const int N = 100;
int n, a[N], b[N];
int ans = 1e9;
inline void Update(int x, int y) {
​    if ((x + y) & 1) return;
​    int tmp = 0;
​    for (int i = 1; i <= n; ++i) tmp += abs(a[i] - x) + abs(b[i] - y);
​    ans = min(ans, tmp);
}
int main() { 
​    scanf("%d", &n);
​    for (int i = 1, x, y; i <= n; ++i) scanf("%d%d", &x, &y), a[i] = x + y, b[i] = x - y;
​    sort(a + 1, a + n + 1);
​    sort(b + 1, b + n + 1);
​    int mid = (n + 1) >> 1;
​    Update(a[mid], b[mid]); 
​    Update(a[mid] + 1, b[mid]); 
​    Update(a[mid], b[mid] + 1); 
​    Update(a[mid] - 1, b[mid]); 
​    Update(a[mid], b[mid] - 1); 
​    printf("%lld", ans >> 1);
​    return 0;
}
输入：
3
1 2
2 1
3 3
输出：______

四、完善程序（共2题10空，每题后四空为3分，其它一空2分，共28分）
1、问题：有n个人站在数轴上，他们的位置是不确定的，但是我们知道m组关系，每组关系可以表示为一个三元组（x，y，z），即x在y的左边，且x，y的距离为z。问这些关系是否合法。
合法输出“Yes”，否则输出“No”。
1≤N≤100 000
0≤M≤200 000
1≤x,y,z≤N

#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m,fa[N],di[N];
inline int ask(int x){
​	if (fa[x]==x)  (1) ;
int t=ask(fa[x]);
 (2) ;
return fa[x]=t;
}
int main(){
scanf("%d%d",&n,&m);
for (int i=1;i<=n;++i) fa[i]=i;
for (int id=1,x,y,z;id<=m;++id){
scanf("%d%d%d",&x,&y,&z);
int u=ask(x),v=ask(y),dx=di[x],dy=di[y];
if (u!=v){
fa[u]=v;
 (3) ;
}else{
if (dx+z!=dy) {
​     puts(" (4) ");
​     return 0;
   }
  }
}
puts(" (5) ");
return 0;
}
2、问题：给你一棵树最多100000个节点，一个有效的k集合是指一个这棵树的路径的集合，其中所有的路径上点数为k并且树上的每个点最多属于一条路径，对于所有小于等于n的自然数k求出有效的k集合的最大大小。
输出n行 第i行表示 有效的i集合的大小。
思路是利用 O(n)的DP可以计算 一个k的答案，然后考虑到随着k增大答案递减。
并且k的答案显然不超过n/k下取整 所以对于大于根号n的k答案最多只有根号n个取值，我们暴力二分确定每一个取值的区间。
对于前根号n个数暴力计算。

#include <bits/stdc++.h>
using namespace std;
const int N = 111111;
const int M = N * 2;
int n, m, fir[N], ne[M], to[M], cnt, x, y, fa[N], who[N], tot;
//who 表示这棵树的先序遍历
bool vis[N]; 
void add(int x, int y) { //连接单向边利用边表存储。
   (6) ;
  fir[x] = cnt;
  to[cnt] = y;
}
void link(int x, int y) {//连接双向边。
  add(x, y);
  add(y, x);
}
#define Foreachson(i, x) for(int i = fir[x]; i; i = ne[i])
//遍历边集 
int dp[N]
int K, ans;
void dfs(int x, int f) {
  fa[x] = f;
   (7) ;
  Foreachson(i, x) {
int V = to[i];
if(V == f) continue;
dfs(V, x);
  }
}
int res[N];
int solve(int k) {
//O(n)计算 k有效集合的答案。
  if(vis[k]) return res[k];
  //记忆化
  if(k == 1) return n;
  ans = 0;
  for(int i = 1; i <= n; ++ i) dp[i] = 0;
  //初始化。 dp[i] 表示 第i个点如果没有被选，假设它和它的父亲断开，连接它的未被选择的链中最长的链长。 dp[i] = -1 表示已选择。
  for(int i = 1; i < n; ++ i) {
 (8) ;
++ dp[V]; // 加入自己。
if(dp[fa[V]] == -1) continue;
if( (9) ) {
dp[fa[V]] = -1;
++ ans;
}
else dp[fa[V]] = max(dp[fa[V]], dp[V]);
  }
  return res[k] = ans;
}
int main() {
  scanf("%d", &n);
  for(int i = 1; i < n; ++ i) {scanf("%d%d", &x, &y)， link(x, y);}
  dfs(1, 0);
  reverse(who + 1, who + n + 1);
  if(n <= 1500) {
for(int i = 1; i <= min(1500, n); ++ i) printf("%d\n", solve(i));
return 0;
  }
  for(int i = 1; i <= 1500; ++ i) printf("%d\n", res[i] = solve(i));
  int last;
  for(int i = 1501; i <= n; i = last + 1) {
//二分下一个最大集合数量不一样的位置在哪里。
 int l = i, r = n
last = i - 1;
int now = solve(i);
if(!now) {
for(int j = i; j <= n; ++ j) printf("%d\n", now);
return 0;
}
while(l <= r) {
int mid = (l + r) >> 1;
if(solve(mid) != now) r = mid - 1;
​	  else  (10) ;
}
for(int j = i; j <= last; ++ j) printf("%d\n", now);
  }
}